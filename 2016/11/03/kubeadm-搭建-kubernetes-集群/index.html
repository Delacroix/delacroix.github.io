<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>kubeadm 搭建 kubernetes 集群 | Delacroix&#39; Blog</title>
  <meta name="author" content="Delacroix">
  
  <meta name="description" content="#[转]kubeadm 搭建 kubernetes 集群原作者链接：点我
距离上一篇 kubernetes 1.4 集群搭建 发布间隔不算太久，自己也不断地在生产和测试环境鼓捣，有不少 “逗比” 的经历，准备写一下具体的 kubeadm 搭建集群的一些坑和踩坑的经验，如果没有使用过 kubeadm ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="kubeadm 搭建 kubernetes 集群"/>
  <meta property="og:site_name" content="Delacroix&#39; Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Delacroix&#39; Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> kubeadm 搭建 kubernetes 集群</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>#[转]kubeadm 搭建 kubernetes 集群<br>原作者链接：<a href="https://mritd.me/2016/10/29/set-up-kubernetes-cluster-by-kubeadm/" target="_blank" rel="external">点我</a></p>
<p>距离上一篇 kubernetes 1.4 集群搭建 发布间隔不算太久，自己也不断地在生产和测试环境鼓捣，有不少 “逗比” 的经历，准备写一下具体的 kubeadm 搭建集群的一些坑和踩坑的经验，如果没有使用过 kubeadm 的同学，最好先看下上面的文章，然后鼓捣一遍，也许并不会成功，但大部分坑再来看此文会有收获<br>一、环境准备</p>
<p>首先环境还是三台虚拟机，虚拟机地址如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">IP 地址</th>
<th style="text-align:right">节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">192.168.1.167</td>
<td style="text-align:right">master</td>
</tr>
<tr>
<td style="text-align:left">192.168.1.189</td>
<td style="text-align:right">node1</td>
</tr>
<tr>
<td style="text-align:left">192.168.1.189</td>
<td style="text-align:right">node2</td>
</tr>
</tbody>
</table>
<p>然后每台机器安装好 docker，至于 rpm 安装包版本下面介绍</p>
<p>二、说点正经事</p>
<p>2.1、安装包从哪来</p>
<p>官方的文档页面更新并不及时，同时他的 yum 源更新也很慢，再者…那他妈可是 Google 的服务器，能特么连上吗？以前总是在国外服务器使用 yumdownloader 下载，然后 scp 到本地，虽然能解决问题，但是蛋碎一地…最后找到了源头，如下</p>
<p>Kubernetes 编译的各种发行版安装包来源于 Github 上的另一个叫 release 的项目，地址 点这里，把这个项目 clone 下来，由于本人是 Centos 用户，所以进入 rpm 目录，在安装好 docker 的机器上执行那个 docker-build.sh 脚本即可编译 rpm 包，最后会生成到当前目录的 output 目录下,截图如下</p>
<p>release</p>
<p>rpm目录</p>
<p>2.2、镜像从哪来</p>
<p>对的，没错，gcr.io 就是 Google 的域名，服务器更不用提，所以在进行 kubeadm init 操作时如果不先把这些镜像 load 进去绝对会卡死不动，以下列出了所需镜像，但是版本号根据 rpm 版本不同可能略有不同，具体怎么看下面介绍</p>
<p>镜像名称    版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gcr.io/google_containers/kube-discovery-amd64	1.0</div><div class="line">gcr.io/google_containers/kubedns-amd64	1.7</div><div class="line">gcr.io/google_containers/kube-proxy-amd64	v1.4.1</div><div class="line">gcr.io/google_containers/kube-scheduler-amd64	v1.4.1</div><div class="line">gcr.io/google_containers/kube-controller-manager-amd64	v1.4.1</div><div class="line">gcr.io/google_containers/kube-apiserver-amd64	v1.4.1</div><div class="line">gcr.io/google_containers/etcd-amd64	2.2.5</div><div class="line">gcr.io/google_containers/kube-dnsmasq-amd64	1.3</div><div class="line">gcr.io/google_containers/exechealthz-amd64	1.1</div><div class="line">gcr.io/google_containers/pause-amd64	3.0</div></pre></td></tr></table></figure>
<p>这些镜像有两种办法可以获取，第一种是利用一台国外的服务器，在上面 pull 下来，然后再 save 成 tar 文件，最后 scp 到本地 load 进去；相对于第一种方式比较坑的是取决于服务器速度，每次搞起来也很蛋疼，第二种方式就是利用 docker hub 做中转，简单的说就是利用 docker hub 的自动构建功能，在 Github 中创建一个 Dockerfile，里面只需要 FROM xxxx 这些 gcr.io 的镜像即可，最后 pull 到本地，然后再 tag 一下</p>
<p>首先创建一个 github 项目，可以直接 fork 我的即可</p>
<p>docker-libray</p>
<p>其中每个 Dockerfile 只需要 FROM 一下即可</p>
<p>Dockerfile</p>
<p>最后在 Docker Hub 上创建自动构建项目</p>
<p>createproject</p>
<p>from github</p>
<p>selectproject</p>
<p>details</p>
<p>最后要手动触发一下，然后 Docker Hub 才会开始给你编译</p>
<p>Tigger</p>
<p>等待完成即可直接 pull 了</p>
<p>success</p>
<p>2.3、镜像版本怎么整</p>
<p>上面已经解决了镜像获取问题，但是一大心病就是 “我特么怎么知道是哪个版本的”，为了发扬 “刨根问底” 的精神，先进行一遍 kubeadm init，这时候绝对卡死，此时进入 /etc/kubernetes/manifests 可以看到许多 json 文件，这些文件中定义了需要哪些基础镜像</p>
<p>all json</p>
<p>image version</p>
<p>从上图中基本可以看到 kubeadm init 的时候会拉取哪些基础镜像了，但是还有一些镜像，仍然无法找到，比如kubedns、pause 等，至于其他的镜像版本，可以从源码中找到，源码位置是 kubernetes/cmd/kubeadm/app/images/images.go 这个文件中，如下所示:</p>
<p>image version</p>
<p>剩余的一些镜像，比如 kube-proxy-amd64、kube-discovery-amd64 两个镜像，其中 kube-discovery-amd64 现在一直是 1.0 版本，源码如下所示</p>
<p>discovery version</p>
<p>kube-proxy-amd64 则是一直跟随基础组件的主版本，也就是说如果从 manifests 中看到 controller 等版本是 v.1.4.4，那么 kube-proxy-amd64 也是这个版本，源码如下</p>
<p>proxy version</p>
<p>最后根据这些版本去 github 上准备相应的 Dockerfile，在利用 Docker Hub 的自动构建 build 一下，再 pull 下来 tag 成对应的镜像名称即可</p>
<p>三、搭建集群</p>
<p>3.1、主机名处理</p>
<p>经过亲测，节点主机名最好为 xxx.xxx 这种域名格式，否则在某些情况下，POD 中跑的程序使用域名解析时可能出现问题，所以先要处理一下主机名</p>
<h1 id="写入-hostname-node-节点后缀改成-node"><a href="#写入-hostname-node-节点后缀改成-node" class="headerlink" title="写入 hostname(node 节点后缀改成 .node)"></a>写入 hostname(node 节点后缀改成 .node)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;192-168-1-167.master&quot; &gt; /etc/hostname</div></pre></td></tr></table></figure>
<h1 id="加入-hosts"><a href="#加入-hosts" class="headerlink" title="加入 hosts"></a>加入 hosts</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;127.0.0.1   192-168-1-167.master&quot; &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure>
<h1 id="不重启情况下使内核生效"><a href="#不重启情况下使内核生效" class="headerlink" title="不重启情况下使内核生效"></a>不重启情况下使内核生效</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl kernel.hostname=192-168-1-167.master</div></pre></td></tr></table></figure>
<h1 id="验证是否修改成功"><a href="#验证是否修改成功" class="headerlink" title="验证是否修改成功"></a>验证是否修改成功</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ~ hostname</div><div class="line">192-168-1-167.master</div><div class="line">3.2、load 镜像</div></pre></td></tr></table></figure>
<p>由于本人已经在 Docker Hub 上处理好了相关镜像，所以直接 pull 下来 tag 一下即可，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">images=(kube-proxy-amd64:v1.4.4 kube-discovery-amd64:1.0 kubedns-amd64:1.7 kube-scheduler-amd64:v1.4.4 kube-controller-manager-amd64:v1.4.4 kube-apiserver-amd64:v1.4.4 etcd-amd64:2.2.5 kube-dnsmasq-amd64:1.3 exechealthz-amd64:1.1 pause-amd64:3.0 kubernetes-dashboard-amd64:v1.4.1)</div><div class="line">for imageName in $&#123;images[@]&#125; ; do</div><div class="line">  docker pull mritd/$imageName</div><div class="line">  docker tag mritd/$imageName gcr.io/google_containers/$imageName</div><div class="line">  docker rmi mritd/$imageName</div><div class="line">done</div></pre></td></tr></table></figure>
<p>3.3、安装 rpm</p>
<p>rpm 获取办法上文已经提到，可以自己编译，这里我已经编译好并维护了一个 yum 源，直接yum install 即可(懒)</p>
<h1 id="添加-yum-源"><a href="#添加-yum-源" class="headerlink" title="添加 yum 源"></a>添加 yum 源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tee /etc/yum.repos.d/mritd.repo &lt;&lt; EOF</div><div class="line">[mritdrepo]</div><div class="line">name=Mritd Repository</div><div class="line">baseurl=https://rpm.mritd.me/centos/7/x86_64</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://cdn.mritd.me/keys/rpm.public.key</div><div class="line">EOF</div></pre></td></tr></table></figure>
<h1 id="刷新cache"><a href="#刷新cache" class="headerlink" title="刷新cache"></a>刷新cache</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum makecache</div></pre></td></tr></table></figure>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y kubelet kubectl kubernetes-cni kubeadm</div></pre></td></tr></table></figure>
<p>3.4、初始化 master</p>
<p>等会有个坑，kubeadm 等相关 rpm 安装后会生成 /etc/kubernetes 目录，而 kubeadm init 时候又会检测这些目录是否存在，如果存在则停止初始化，所以要先清理一下，以下清理脚本来源于 官方文档 Tear down 部分，该脚本同样适用于初始化失败进行重置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl stop kubelet;</div></pre></td></tr></table></figure>
<h1 id="注意-下面这条命令会干掉所有正在运行的-docker-容器，"><a href="#注意-下面这条命令会干掉所有正在运行的-docker-容器，" class="headerlink" title="注意: 下面这条命令会干掉所有正在运行的 docker 容器，"></a>注意: 下面这条命令会干掉所有正在运行的 docker 容器，</h1><h1 id="如果要进行重置操作，最好先确定当前运行的所有容器都能干掉-干掉不影响业务-，"><a href="#如果要进行重置操作，最好先确定当前运行的所有容器都能干掉-干掉不影响业务-，" class="headerlink" title="如果要进行重置操作，最好先确定当前运行的所有容器都能干掉(干掉不影响业务)，"></a>如果要进行重置操作，最好先确定当前运行的所有容器都能干掉(干掉不影响业务)，</h1><h1 id="否则的话最好手动删除-kubeadm-创建的相关容器-gcr-io-相关的"><a href="#否则的话最好手动删除-kubeadm-创建的相关容器-gcr-io-相关的" class="headerlink" title="否则的话最好手动删除 kubeadm 创建的相关容器(gcr.io 相关的)"></a>否则的话最好手动删除 kubeadm 创建的相关容器(gcr.io 相关的)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker rm -f -v $(docker ps -q);</div><div class="line">find /var/lib/kubelet | xargs -n 1 findmnt -n -t tmpfs -o TARGET -T | uniq | xargs -r umount -v;</div><div class="line">rm -r -f /etc/kubernetes /var/lib/kubelet /var/lib/etcd;</div></pre></td></tr></table></figure>
<p>还有个坑，初始化以前记得一定要启动 kubelet，虽然你 systemctl status kubelet 看着他是启动失败，但是也得启动，否则绝壁卡死</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl enable kubelet</div><div class="line">systemctl start kubelet</div></pre></td></tr></table></figure>
<p>等会等会，还有坑，新版本直接 init 会提示 ebtables not found in system path 错误，所以还得先安装一下这个包在初始化</p>
<h1 id="安装-ebtables"><a href="#安装-ebtables" class="headerlink" title="安装 ebtables"></a>安装 ebtables</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y ebtables</div></pre></td></tr></table></figure>
<p>最后见证奇迹的时刻</p>
<h1 id="初始化并指定-apiserver-监听地址"><a href="#初始化并指定-apiserver-监听地址" class="headerlink" title="初始化并指定 apiserver 监听地址"></a>初始化并指定 apiserver 监听地址</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm init --api-advertise-addresses 192.168.1.167</div></pre></td></tr></table></figure>
<p>完美截图如下</p>
<p>init master</p>
<p>这里再爆料一个坑，底下的 kubeadm join –token=b17964.5d8a3c14e99cf6aa 192.168.1.167 这条命令一定保存好，因为后期没法重现的，你们老大再让你添加机器的时候如果没这个你会哭的</p>
<p>3.5、加入 node</p>
<p>上面所有坑大约说的差不多了，直接上命令了</p>
<h1 id="处理主机名"><a href="#处理主机名" class="headerlink" title="处理主机名"></a>处理主机名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;192-168-1-189.node&quot; &gt; /etc/hostname </div><div class="line">echo &quot;127.0.0.1   192-168-1-189.node&quot; &gt;&gt; /etc/hosts</div><div class="line">sysctl kernel.hostname=192-168-1-189.node</div></pre></td></tr></table></figure>
<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">images=(kube-proxy-amd64:v1.4.4 kube-discovery-amd64:1.0 kubedns-amd64:1.7 kube-scheduler-amd64:v1.4.4 kube-controller-manager-amd64:v1.4.4 kube-apiserver-amd64:v1.4.4 etcd-amd64:2.2.5 kube-dnsmasq-amd64:1.3 exechealthz-amd64:1.1 pause-amd64:3.0 kubernetes-dashboard-amd64:v1.4.1)</div><div class="line">for imageName in $&#123;images[@]&#125; ; do</div><div class="line">  docker pull mritd/$imageName</div><div class="line">  docker tag mritd/$imageName gcr.io/google_containers/$imageName</div><div class="line">  docker rmi mritd/$imageName</div><div class="line">done</div></pre></td></tr></table></figure>
<h1 id="装-rpm"><a href="#装-rpm" class="headerlink" title="装 rpm"></a>装 rpm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tee /etc/yum.repos.d/mritd.repo &lt;&lt; EOF</div><div class="line">[mritdrepo]</div><div class="line">name=Mritd Repository</div><div class="line">baseurl=https://rpm.mritd.me/centos/7/x86_64</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://cdn.mritd.me/keys/rpm.public.key</div><div class="line">EOF</div><div class="line">yum makecache</div><div class="line">yum install -y kubelet kubectl kubernetes-cni kubeadm ebtables</div></pre></td></tr></table></figure>
<h1 id="清理目录-没初始化过只需要删目录"><a href="#清理目录-没初始化过只需要删目录" class="headerlink" title="清理目录(没初始化过只需要删目录)"></a>清理目录(没初始化过只需要删目录)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -r -f /etc/kubernetes /var/lib/kubelet /var/lib/etcd;</div></pre></td></tr></table></figure>
<h1 id="启动-kubelet"><a href="#启动-kubelet" class="headerlink" title="启动 kubelet"></a>启动 kubelet</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl enable kubelet</div><div class="line">systemctl start kubelet</div></pre></td></tr></table></figure>
<h1 id="初始化加入集群"><a href="#初始化加入集群" class="headerlink" title="初始化加入集群"></a>初始化加入集群</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm join --token=b17964.5d8a3c14e99cf6aa 192.168.1.167</div></pre></td></tr></table></figure>
<p>同样完美截图</p>
<p>join master</p>
<p>get node</p>
<p>3.6、部署 weave 网络</p>
<p>再没部署 weave 时，dns 是启动不了的，如下</p>
<p>dns not work</p>
<p>官方给出的命令是这样的</p>
<p>kubectl create -f <a href="https://git.io/weave-kube" target="_blank" rel="external">https://git.io/weave-kube</a><br>本着 “刨根问底挖祖坟” 的精神，先把这个 yaml 搞下来</p>
<p>wget <a href="https://git.io/weave-kube" target="_blank" rel="external">https://git.io/weave-kube</a> -O weave-kube.yaml<br>然后同样的套路，打开看一下镜像，利用 Docker Hub 做中转，搞下来再 load 进去，然后 create -f 就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker pull mritd/weave-kube:1.7.2</div><div class="line">docker tag mritd/weave-kube:1.7.2 weaveworks/weave-kube:1.7.2</div><div class="line">docker rmi mritd/weave-kube:1.7.2</div><div class="line">kubectl create -f weave-kube.yaml</div></pre></td></tr></table></figure>
<p>完美截图</p>
<p>create weave</p>
<p>3.7、部署 dashboard</p>
<p>dashboard 的命令也跟 weave 的一样，不过有个大坑，默认的 yaml 文件中对于 image 拉取策略的定义是 无论何时都会去拉取镜像，导致即使你 load 进去也无卵用，所以还得先把 yaml 搞下来然后改一下镜像拉取策略，最后再 create -f 即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml -O kubernetes-dashboard.yaml</div></pre></td></tr></table></figure>
<p>编辑 yaml 改一下 imagePullPolicy，把 Always 改成 IfNotPresent(本地没有再去拉取) 或者 Never(从不去拉取) 即可</p>
<p>IfNotPresent</p>
<p>最后再利用 Dokcer Hub 中转，然后创建(实际上 dashboard 已经有了 v1.4.1，我这里已经改了)</p>
<p>kubectl create -f kubernetes-dashboard.yaml<br>截图如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create dashboard</div></pre></td></tr></table></figure>
<p>通过 describe 命令我们可以查看其暴露出的 NodePoint,然后便可访问</p>
<p>describe dashboard</p>
<p>show dashboard</p>
<p>四、其他的一些坑</p>
<p>还有一些其他的坑等着大家去摸索，其中有一个是 DNS 解析错误，表现形式为 POD 内的程序通过域名访问解析不了，cat 一下容器的 /etc/resolv.conf发现指向的 dns 服务器与 kubectl get svc –namespace=kube-system 中的 kube-dsn 地址不符；解决办法就是 编辑节点的 /etc/systemd/system/kubelet.service.d/10-kubeadm.conf 文件，更改 KUBELET_DNS_ARGS 地址为 get svc 中的 kube-dns 地址，然后重启 kubelet 服务，重新杀掉 POD 让 kubernetes 重建即可</p>
<p>modify kube-dns</p>
<p>其他坑欢迎大家补充</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
		
          <li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>上一页</a></li>
        

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2016/11/03/LVS集群中的IP负载均衡技术-1/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">留言</h2>

  
</section>

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-11-03 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/操作系统-Linux-Kubernetes-Docker/">操作系统[Linux|Kubernetes|Docker]<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 Delacroix
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
